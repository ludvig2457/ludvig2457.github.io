<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LudvigEditor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, #4b2fbf, #2b1a55, #14142e);
    font-family: system-ui;
}

/* ===== TOP BAR ===== */
#topbar {
    height: 46px;
    display: flex;
    align-items: center;
    padding: 0 14px;
    color: #fff;
    font-weight: 600;
    letter-spacing: .4px;
    background: linear-gradient(135deg, rgba(90,60,200,.85), rgba(60,40,160,.85));
    backdrop-filter: blur(20px) saturate(160%);
    box-shadow: 0 6px 30px rgba(0,0,0,.5);
    border-bottom: 1px solid rgba(255,255,255,.12);
    position: relative;
    gap: 10px;
}

/* ===== SEARCH INPUT ===== */
#searchInput {
    padding: 4px 8px;
    border-radius: 6px;
    border: none;
    outline: none;
    opacity: 0.85;
    font-size: 14px;
    background: rgba(255,255,255,.12);
    color: #fff;
}

/* ===== LANGUAGE SELECT ===== */
#langSelect {
    padding: 4px 8px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
    background: rgba(255,255,255,.12);
    color: #fff;
}

#langSelect option {
    color: black;
    background: white;
}

/* ===== EDITOR ===== */
#editor {
    width: 100%;
    height: calc(100% - 46px);
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width: 10px; }
::-webkit-scrollbar-thumb { background: rgba(130,130,220,.4); border-radius: 10px; }

/* ===== ERROR HIGHLIGHT ===== */
.errorLine {
    background: rgba(255, 107, 107, 0.2);
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
</head>

<body>
<div id="topbar">
    ‚ö° LudvigEditor ‚Äî VS Code style
    <input type="text" id="searchInput" placeholder="Search..." />
    <select id="langSelect">
        <option value="python">Python</option>
        <option value="javascript">JavaScript</option>
        <option value="typescript">TypeScript</option>
        <option value="html">HTML</option>
        <option value="css">CSS</option>
        <option value="json">JSON</option>
        <option value="c">C</option>
        <option value="cpp">C++</option>
        <option value="java">Java</option>
        <option value="markdown">Markdown</option>
        <option value="shell">Bash</option>
        <option value="ruby">Ruby</option>
        <option value="php">PHP</option>
        <option value="go">Go</option>
        <option value="rust">Rust</option>
        <option value="kotlin">Kotlin</option>
        <option value="swift">Swift</option>
        <option value="lua">Lua</option>
        <option value="sql">SQL</option>
        <option value="yaml">YAML</option>
        <option value="xml">XML</option>
        <option value="plaintext">Plain Text</option>
    </select>
</div>
<div id="editor"></div>

<script>
require.config({ paths: { vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs" } });

require(["vs/editor/editor.main"], function () {

    // ===== THEME =====
    monaco.editor.defineTheme("ludvig-gradient", {
        base: "vs-dark",
        inherit: true,
        rules: [
            { token: "comment", foreground: "7fd88b" },
            { token: "keyword", foreground: "c792ea" },
            { token: "number", foreground: "b5cea8" },
            { token: "string", foreground: "f6c177" },
            { token: "type.identifier", foreground: "4ec9b0" },
            { token: "function", foreground: "82aaff" },
        ],
        colors: {
            "editor.background": "#0f1224",
            "editor.lineHighlightBackground": "#1c2040",
            "editorCursor.foreground": "#ffffff",
            "editor.selectionBackground": "#2f3368",
        }
    });

    // ===== EDITOR =====
    window.editor = monaco.editor.create(document.getElementById("editor"), {
        value: "# LudvigEditor\nprint('Hello from LudvigEditor! üöÄ')\n\n# Try autocomplete:\n# Type 'def ' or 'import ' or 'print('",
        language: "python",
        theme: "ludvig-gradient",
        automaticLayout: true,
        fontFamily: "JetBrains Mono, Consolas, monospace",
        fontSize: 14,
        fontLigatures: true,
        smoothScrolling: true,
        cursorSmoothCaretAnimation: "on",
        minimap: { enabled: true },
        wordWrap: "on",
        dragAndDrop: true,
        suggestOnTriggerCharacters: true,
        quickSuggestions: { other: true, comments: false, strings: true },
        parameterHints: { enabled: true }
    });

    // ===== PYTHON AUTOCOMPLETE =====
    monaco.languages.registerCompletionItemProvider('python', {
        provideCompletionItems: function(model, position) {
            var word = model.getWordUntilPosition(position);
            var range = {
                startLineNumber: position.lineNumber,
                startColumn: word.startColumn,
                endLineNumber: position.lineNumber,
                endColumn: word.endColumn
            };
            
            // –ë–∞–∑–æ–≤—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –¥–ª—è Python
            var suggestions = [
                {
                    label: 'print',
                    kind: monaco.languages.CompletionItemKind.Function,
                    insertText: 'print(${1:value})',
                    documentation: 'Print to console'
                },
                {
                    label: 'def',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'def ${1:function_name}(${2:args}):\\n\\t${3:pass}',
                    documentation: 'Define a function'
                },
                {
                    label: 'class',
                    kind: monaco.languages.CompletionItemKind.Class,
                    insertText: 'class ${1:ClassName}:\\n\\tdef __init__(self${2:, args}):\\n\\t\\t${3:pass}',
                    documentation: 'Define a class'
                },
                {
                    label: 'if',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'if ${1:condition}:\\n\\t${2:pass}',
                    documentation: 'If statement'
                },
                {
                    label: 'for',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'for ${1:item} in ${2:iterable}:\\n\\t${3:pass}',
                    documentation: 'For loop'
                },
                {
                    label: 'while',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'while ${1:condition}:\\n\\t${2:pass}',
                    documentation: 'While loop'
                },
                {
                    label: 'import',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'import ',
                    documentation: 'Import module'
                },
                {
                    label: 'from',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'from ${1:module} import ${2:name}',
                    documentation: 'Import from module'
                },
                {
                    label: 'return',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'return ',
                    documentation: 'Return value'
                },
                {
                    label: 'try',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'try:\\n\\t${1:pass}\\nexcept ${2:Exception}:\\n\\t${3:pass}',
                    documentation: 'Try-except block'
                },
                {
                    label: 'with',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'with ${1:expression} as ${2:var}:\\n\\t${3:pass}',
                    documentation: 'With statement'
                },
                {
                    label: 'async',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'async ',
                    documentation: 'Async function'
                },
                {
                    label: 'await',
                    kind: monaco.languages.CompletionItemKind.Keyword,
                    insertText: 'await ',
                    documentation: 'Await expression'
                }
            ];
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ Python
            var builtins = ['abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 
                          'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 
                          'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 
                          'enumerate', 'eval', 'exec', 'filter', 'float', 'format', 
                          'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 
                          'help', 'hex', 'id', 'input', 'int', 'isinstance', 
                          'issubclass', 'iter', 'len', 'list', 'locals', 'map', 
                          'max', 'memoryview', 'min', 'next', 'object', 'oct', 
                          'open', 'ord', 'pow', 'print', 'property', 'range', 
                          'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 
                          'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 
                          'type', 'vars', 'zip', '__import__'];
            
            builtins.forEach(function(func) {
                if (func !== 'print') { // print —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω
                    suggestions.push({
                        label: func,
                        kind: monaco.languages.CompletionItemKind.Function,
                        insertText: func + '(${1})',
                        documentation: 'Built-in function'
                    });
                }
            });
            
            return { suggestions: suggestions };
        }
    });

    // ===== LANGUAGE SWITCH =====
    const langSelect = document.getElementById("langSelect");
    langSelect.addEventListener("change", () => {
        monaco.editor.setModelLanguage(editor.getModel(), langSelect.value);
    });

    // ===== SEARCH =====
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("input", () => {
        const term = searchInput.value;
        const findController = editor.getContribution('editor.contrib.findController');
        if(term) {
            editor.getAction('actions.find').run().then(() => {
                findController.getState().change({ searchString: term }, false);
            });
        } else {
            findController.getState().change({ searchString: '' }, false);
        }
    });

    // ===== SYNTAX ERROR HIGHLIGHTING =====
    let errorDecorations = [];
    editor.onDidChangeModelContent(function() {
        var model = editor.getModel();
        var content = model.getValue();
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –¥–µ–∫–æ—Ä–∞—Ü–∏–∏
        errorDecorations = editor.deltaDecorations(errorDecorations, []);
        
        // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ (–¥–ª—è –¥–µ–º–æ)
        var lines = content.split('\\n');
        var newDecorations = [];
        
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—Ç—Å—Ç—É–ø—ã –ø–µ—Ä–µ–¥ print (–¥–ª—è –¥–µ–º–æ)
            if (line.includes('  print(') || line.includes('    print(')) {
                newDecorations.push({
                    range: new monaco.Range(i+1, 1, i+1, line.length+1),
                    options: {
                        isWholeLine: true,
                        className: 'errorLine',
                        hoverMessage: { value: '‚ö†Ô∏è –í–æ–∑–º–æ–∂–Ω–∞—è –æ—à–∏–±–∫–∞ –æ—Ç—Å—Ç—É–ø–∞' }
                    }
                });
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–¥–ª—è –¥–µ–º–æ)
            if (line.includes('print(') && !line.includes('"') && !line.includes("'")) {
                var match = line.match(/print\\(([^)]+)\\)/);
                if (match) {
                    var arg = match[1].trim();
                    if (!['"', "'"].some(char => arg.includes(char)) && 
                        !['True', 'False', 'None', 'self'].includes(arg)) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤—ã—à–µ
                        var varDefined = false;
                        for (var j = 0; j < i; j++) {
                            if (lines[j].includes(arg + ' =') || lines[j].includes('def ' + arg)) {
                                varDefined = true;
                                break;
                            }
                        }
                        
                        if (!varDefined) {
                            newDecorations.push({
                                range: new monaco.Range(i+1, line.indexOf(arg)+1, i+1, line.indexOf(arg)+arg.length+1),
                                options: {
                                    inlineClassName: 'errorInline',
                                    hoverMessage: { value: '‚ö†Ô∏è –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞' }
                                }
                            });
                        }
                    }
                }
            }
        }
        
        errorDecorations = editor.deltaDecorations(errorDecorations, newDecorations);
    });

    // ===== API FOR PYQT =====
    window.setCode = (code, lang = "python") => {
        monaco.editor.setModelLanguage(editor.getModel(), lang);
        editor.setValue(code);
    };

    window.getCode = () => editor.getValue();
    
    // –ù–æ–≤—ã–π API –¥–ª—è –¥–µ–±–∞–≥–≥–µ—Ä–∞
    window.getCurrentLine = () => {
        var position = editor.getPosition();
        return position.lineNumber;
    };
    
    window.pySave = null;
    
    // –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
    setTimeout(() => {
        if (window.pyQtBridge && window.pyQtBridge.editorReady) {
            window.pyQtBridge.editorReady();
        }
    }, 1000);
});

// –ú–æ—Å—Ç –¥–ª—è –æ–±—â–µ–Ω–∏—è —Å PyQt
window.pyQtBridge = {
    setBreakpoint: function(line) {
        console.log('Toggle breakpoint at line:', line);
        // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è —Ç–æ—á–µ–∫ –æ—Å—Ç–∞–Ω–æ–≤–∞
    },
    
    getLineForBreakpoint: function() {
        if (window.editor) {
            var position = window.editor.getPosition();
            return position.lineNumber;
        }
        return 1;
    },
    
    editorReady: function() {
        console.log('Monaco Editor ready!');
    }
};
</script>
</body>
</html>
